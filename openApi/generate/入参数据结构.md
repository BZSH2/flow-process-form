# ApiGenerator 入参数据结构说明

`ApiGenerator` 类的核心入参 `openAPIData` 采用了灵活的递归结构 `APIDataType`，以支持多种复杂的 API 定义组织方式。本文档详细说明该数据结构的定义、支持的格式以及处理逻辑。

## 1. 类型定义

### 1.1 `APIDataType`

`APIDataType` 是一个递归类型，可以表示单个 OpenAPI 对象、OpenAPI 对象数组，或者是嵌套的字典结构。

```typescript
interface APIDataType {
  // 索引签名，支持字符串键（用于对象/字典结构）
  [key: string]: OpenAPIObject[] | APIDataType | APIDataType[];
  // 索引签名，支持数字键（用于数组结构）
  [index: number]: OpenAPIObject[] | APIDataType | APIDataType[];
}
```

为了方便理解，可以将其展开为以下联合类型：

```typescript
type APIDataType =
  | OpenAPIObject                    // 单个 OpenAPI 对象 (尽管类型定义上可能被包含在更宽泛的结构中，但逻辑上支持)
  | OpenAPIObject[]                  // OpenAPI 对象数组
  | { [key: string]: APIDataType }   // 嵌套字典，值可以是上述任意类型
  | APIDataType[]                    // 嵌套数组
```

### 1.2 `OpenAPIObject`

这是标准的 OpenAPI 3.0/3.1 规范对象，包含 `openapi` 版本号、`info` 信息、`paths` 路径定义、`components` 组件定义等核心字段。

## 2. 支持的数据结构示例

`ApiGenerator` 通过 `generateApi` 方法递归处理输入数据，支持以下几种常见结构：

### 2.1 扁平数组结构 (最简单)

直接传入一个包含多个 OpenAPI 对象的数组。生成器会遍历数组，为每个 OpenAPI 对象生成对应的 API 代码。

```javascript
const apiData = [
  { openapi: '3.0.1', info: { title: 'UserAPI' }, paths: { ... } },
  { openapi: '3.0.1', info: { title: 'OrderAPI' }, paths: { ... } }
];
```

**输出结构：**
```
output/
  ├── UserAPI/
  └── OrderAPI/
```

### 2.2 嵌套字典结构 (按模块分组)

使用对象键值对来组织 API，键名（key）将作为文件夹名称的一部分。这种结构适合按业务模块划分 API。

```javascript
const apiData = {
  "SaaS模块": [
    { openapi: '3.0.1', info: { title: 'TenantService' }, paths: { ... } }
  ],
  "电商模块": {
    "交易中心": [
      { openapi: '3.0.1', info: { title: 'PaymentService' }, paths: { ... } }
    ],
    "库存中心": { openapi: '3.0.1', info: { title: 'InventoryService' }, paths: { ... } }
  }
};
```

**输出结构：**
```
output/
  ├── SaaS模块/
  │   └── TenantService/
  └── 电商模块/
      ├── 交易中心/
      │   └── PaymentService/
      └── 库存中心/
          └── InventoryService/
```

### 2.3 混合结构

数组与对象可以任意嵌套。

```javascript
const apiData = [
  { openapi: '3.0.1', info: { title: 'CommonAPI' }, paths: { ... } }, // 直接在根目录生成
  {
    "External": [
      { openapi: '3.0.1', info: { title: 'ThirdPartyAPI' }, paths: { ... } }
    ]
  }
];
```

## 3. 处理逻辑 (`generateApi` 方法)

生成器采用递归方式处理 `apiData`，逻辑如下：

1.  **数组处理 (`isArray(apiData)`)**:
    *   遍历数组中的每一项 `item`。
    *   **如果是 OpenAPI 对象 (`isOpenAPI(item)`)**: 直接调用 `generateMain` 生成代码。
    *   **如果是普通对象 (`isObject(item)`)**: 递归调用 `generateApi(item)`，继续深入解析。

2.  **对象处理 (`isObject(apiData)`)**:
    *   **如果是 OpenAPI 对象 (`isOpenAPI(apiData)`)**: 直接调用 `generateMain` 生成代码（此时该对象被视为一个独立的 API 定义）。
    *   **如果不是 OpenAPI 对象**: 被视为目录结构容器。
        *   遍历对象的每个键值对 `(key, value)`。
        *   将 `key` 作为子目录名，拼接到当前 `outputFolder` 后。
        *   创建该子目录。
        *   递归调用 `generateApi(value, newOutputFolder)`。

## 4. 关键依赖

*   **`isOpenAPI(obj)`**: 用于判断一个对象是否为有效的 OpenAPI 定义。通常检查 `openapi` 字段是否存在且版本号符合要求 (e.g., `3.0.1`)。
*   **`resolveTypeName`**: 用于处理 `info.title`，将其转换为合法的文件/文件夹名称。

## 5. 注意事项

*   **递归深度**: 虽然支持无限嵌套，但建议保持结构扁平，以免生成的目录层级过深。
*   **命名冲突**: 最终生成的 API 文件夹名称取自 `OpenAPIObject.info.title`。确保同一层级下的 API `title` 唯一，否则会发生覆盖。
*   **数据校验**: 确保传入的 OpenAPI 对象符合标准规范，否则可能导致生成失败或 TypeScript 类型错误。
